// Copyright {{.ServiceEntity.Year}} The go-exactonline AUTHORS. All rights reserved.
//
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.
// Code generated by gen-services.go; DO NOT EDIT.
package {{.ServiceEntity.Package}}

// {{.EndpointServiceName}} is responsible for communicating with
// the {{.Name}} endpoint of the {{.ServiceEntity.Name}} service.
type {{.EndpointServiceName}} service

// {{.Name}}: {{.Description}}
// Service: {{.Service}}
// Entity: {{.Name}}
// URL: {{.URL}}
// HasWebhook: {{.HasWebhook}}
// IsInBeta: {{.IsInBeta}}
// Methods: {{range .Methods}}{{.}} {{end}}
// Endpoint docs: https://start.exactonline.nl/docs/{{.Docs}}
type {{.Name}} struct {
	MetaData *api.MetaData `json:"__metadata,omitempty"`
{{- range .Properties -}}
	{{if .Name}}
	// {{.Name}}:
	{{- range $i, $e := .Description -}}
	{{if $i}} //{{end}} {{ $e }}
	{{- end}}
	{{.Name}} *{{.Type}} `json:"{{.OriginalName}},{{if .NeedsStringJSON}}string,{{end}}omitempty"`
	{{end -}}
{{end}}
}

func (e *{{.Name}}) GetPrimary() *{{.PrimaryProperty.Type}} {
	return e.{{.PrimaryProperty.Name}}
}

func (s *{{.EndpointServiceName}}) UserHasRights(ctx context.Context, division int, method string) (bool, error) {
	return s.client.UserHasRights(ctx, division, "{{.EndpointForPermission}}", method)
}

{{ if (.HasMethod "GET")}}
// List the {{.Name}} entities{{ if .NeedsDivision }} in the provided division{{end}}.
// If all is true, all the paginated results are fetched; if false, list the first page.
func (s *{{.EndpointServiceName}}) List(ctx context.Context,{{ if .NeedsDivision}} division int,{{end}} all bool, o *api.ListOptions) ([]*{{.Name}}, error) {
	var entities []*{{.Name}}
	{{- if .NeedsDivision}}
	u, _ := s.client.ResolvePathWithDivision("{{.URL}}", division) // #nosec
	{{else}}
	u, _ := s.client.ResolveURL("{{.URL}}") // #nosec
	{{end -}}

    api.AddListOptionsToURL(u, o)
	
	if all {
		err := s.client.ListRequestAndDoAll(ctx, u.String(), &entities)
		return entities, err
	}
	_, _, err := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, &entities)
	return entities, err
}

// Get the {{.Name}} entitiy{{ if .NeedsDivision }} in the provided division{{end}}.
func (s *{{.EndpointServiceName}}) Get(ctx context.Context,{{ if .NeedsDivision}} division int,{{end}} id *{{.PrimaryProperty.Type}}) (*{{.Name}}, error) {
	{{- if .NeedsDivision}}
	b, _ := s.client.ResolvePathWithDivision("{{.URL}}", division) // #nosec
	{{else}}
	b, _ := s.client.ResolveURL("{{.URL}}") // #nosec
	{{end -}}

	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return nil, err
	}
	
	e := &{{.Name}}{{"{}"}}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "GET", u.String(), nil, e)
	return e, requestError
}
{{end}}


{{ if (.HasMethod "POST")}}
// New returns an empty {{.Name}} entity
func (s *{{.EndpointServiceName}}) New() *{{.Name}} {
	return &{{.Name}}{{"{}"}}
}

// Create the {{.Name}} entity{{ if .NeedsDivision }} in the provided division{{end}}.
func (s *{{.EndpointServiceName}}) Create(ctx context.Context,{{ if .NeedsDivision}} division int,{{end}} entity *{{.Name}}) (*{{.Name}}, error) {
	{{- if .NeedsDivision}}
	u, _ := s.client.ResolvePathWithDivision("{{.URL}}", division) // #nosec
	{{else}}
	u, _ := s.client.ResolveURL("{{.URL}}") // #nosec
	{{end -}}

	e := &{{.Name}}{{"{}"}}
	_, _, err := s.client.NewRequestAndDo(ctx, "POST", u.String(), entity, e)
	if err != nil {
		return nil, err
	}
	return e, nil
}
{{end}}


{{ if (.HasMethod "PUT")}}
// Update the {{.Name}} entity{{ if .NeedsDivision }} in the provided division{{end}}.
func (s *{{.EndpointServiceName}}) Update(ctx context.Context,{{ if .NeedsDivision}} division int,{{end}} entity *{{.Name}}) (*{{.Name}}, error) {
	{{- if .NeedsDivision}}
	b, _ := s.client.ResolvePathWithDivision("{{.URL}}", division) // #nosec
	{{else}}
	b, _ := s.client.ResolveURL("{{.URL}}") // #nosec
	{{end -}}

	u, err := api.AddOdataKeyToURL(b, entity.GetPrimary())
	if err != nil {
		return nil, err
	}

	e := &{{.Name}}{{"{}"}}
	_, _, requestError := s.client.NewRequestAndDo(ctx, "PUT", u.String(), entity, e)
	return e, requestError
}
{{end}}

{{ if (.HasMethod "DELETE")}}
// Delete the {{.Name}} entity{{ if .NeedsDivision }} in the provided division{{end}}.
func (s *{{.EndpointServiceName}}) Delete(ctx context.Context,{{ if .NeedsDivision}} division int,{{end}} id *{{.PrimaryProperty.Type}}) error {
	{{- if .NeedsDivision}}
	b, _ := s.client.ResolvePathWithDivision("{{.URL}}", division) // #nosec
	{{else}}
	b, _ := s.client.ResolveURL("{{.URL}}") // #nosec
	{{end -}}

	u, err := api.AddOdataKeyToURL(b, id)
	if err != nil {
		return err
	}

	_, r, requestError := s.client.NewRequestAndDo(ctx, "DELETE", u.String(), nil, nil)
	if requestError != nil {
		return requestError
	}

	if r.StatusCode != http.StatusNoContent {
		body, _ := ioutil.ReadAll(r.Body) // #nosec
		return fmt.Errorf("Failed with status %v and body %v", r.StatusCode, body)
	}

	return nil
}
{{end}}