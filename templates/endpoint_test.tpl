// Copyright {{.ServiceEntity.Year}} The go-exactonline AUTHORS. All rights reserved.
//
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.
// Code generated by gen-services.go; DO NOT EDIT.
package {{.ServiceEntity.Package}}

func {{.Name}}PrimaryPropertySample() *{{.PrimaryProperty.Type}} {
	{{- if eq .PrimaryProperty.Type "types.GUID"}}v := types.NewGUID(){{end}}
	{{- if eq .PrimaryProperty.Type "int"}}v := 100{{end}}
	{{- if eq .PrimaryProperty.Type "int64"}}v := int64(100){{end}}
	{{- if eq .PrimaryProperty.Type "string"}}v := "100"{{end}}
	return &v
}

func {{.Name}}EntityWithPopulatedPrimaryProperty() *{{.Name}} {
	return &{{.Name}}{{"{"}}{{.PrimaryProperty.Name}}: {{.Name}}PrimaryPropertySample()}
}

func {{.Name}}StringOfPrimaryProperty(v *{{.PrimaryProperty.Type}}) string {
	{{ if eq .PrimaryProperty.Type "types.GUID"}}return v.String(){{end -}}
	{{ if eq .PrimaryProperty.Type "int"}}return strconv.Itoa(*v){{end -}}
	{{ if eq .PrimaryProperty.Type "int64"}}return strconv.Itoa(int(*v)){{end -}}
	{{ if eq .PrimaryProperty.Type "string"}}return *v{{end -}}
}

func {{.Name}}StringJSONOfPrimaryProperty(v *{{.PrimaryProperty.Type}}) string {
	b, _ := json.Marshal(v)
	return string(b)
}

func Test{{.EndpointServiceName}}_GetPrimary(t *testing.T) {
	var want {{.PrimaryProperty.Type}}
	n := &{{.Name}}{{"{"}}{{.PrimaryProperty.Name}}: &want{{"}"}}

	if got := n.GetPrimary(); !reflect.DeepEqual(*got, want) {
		t.Errorf("{{.EndpointServiceName}}.GetPrimary() failed, got: %v, want: %v", *got, want)
	}
}

func Test{{.EndpointServiceName}}_UserHasRights(t *testing.T) {
	s, mux, _, teardown := setup()
	defer teardown()

	u, e := s.client.ResolvePathWithDivision("/api/v1/{division}/users/UserHasRights", 0)
	if e != nil {
		t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.List returned error: %v", e)
	}

	acceptHeaders := []string{"application/json"}

	mux.HandleFunc(u.Path, func(w http.ResponseWriter, r *http.Request) {
		testMethod(t, r, "GET")
		testHeader(t, r, "Accept", strings.Join(acceptHeaders, ", "))

		q := r.URL.Query()

		if got, want := q.Get("endpoint"), "'{{.EndpointForPermission}}'"; got != want {
			t.Errorf("endpoint query param doesn't match, got: %v, want: %v", got, want)
		}

		if got, want := q.Get("method"), "GET"; got != want {
			t.Errorf("method query param doesn't match, got: %v, want: %v", got, want)
		}

		fmt.Fprint(w, `{ "d": { "UserHasRights": true } }`)
	})

	got, err := s.{{.Name}}.UserHasRights(context.Background(), 0, "GET")
	if err != nil {
		t.Errorf("s.{{.Name}}.UserHasRights should not return an error = %v", err)
	}

	if got != true {
		t.Errorf("s.{{.Name}}.UserHasRights should return true, got: %v", got)
	}
}

{{ if (.HasMethod "GET")}}
func Test{{.EndpointServiceName}}_List_all(t *testing.T) {
	s, mux, _, teardown := setup()
	defer teardown()

	acceptHeaders := []string{"application/json"}

    opts1 := api.NewListOptions()
    opts1.Select.Add("*")
	u, e := s.client.ResolvePathWithDivision("{{.URL}}", 0)
	if e != nil {
		t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.List returned error: %v, with url {{.URL}}?$select=*", e)
	}
    api.AddListOptionsToURL(u, opts1)

	opts2 := api.NewListOptions()
	opts2.Select.Add("*")
	opts2.SkipToken.Set(types.NewGUID())
	u2, e2 := s.client.ResolvePathWithDivision("{{.URL}}", 0)
	if e2 != nil {
		t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.List returned error: %v, with url {{.URL}}?$skiptoken=foo", e2)
	}
    api.AddListOptionsToURL(u2, opts2)

	g := {{.Name}}PrimaryPropertySample()
	gs := {{.Name}}StringJSONOfPrimaryProperty(g)

	mux.HandleFunc(u.Path, func(w http.ResponseWriter, r *http.Request) {
		testMethod(t, r, "GET")
		testHeader(t, r, "Accept", strings.Join(acceptHeaders, ", "))
		if r.URL.Query().Get("$skiptoken") != "" {
			fmt.Fprint(w, `{ "d": { "__next": "", "results": []}}`)
		} else {
			fmt.Fprint(w, `{ "d": { "__next": "` + u2.String() +  `", "results": [{ "{{.PrimaryProperty.Name}}": `+ gs + `}]}}`)
		}
	})

	entities, err := s.{{.Name}}.List(context.Background(),{{ if .NeedsDivision}} 0,{{end}} true, opts1)
	if err != nil {
		t.Errorf("{{.EndpointServiceName}}.List returned error: %v", err)
	}

	want := {{"[]"}}*{{.Name}}{{"{{"}}{{.PrimaryProperty.Name}}: g{{"}}"}}
	if !reflect.DeepEqual(entities, want) {
		t.Errorf("{{.EndpointServiceName}}.List returned %+v, want %+v", entities, want)
	}
}

func Test{{.EndpointServiceName}}_List(t *testing.T) {
	s, mux, _, teardown := setup()
	defer teardown()

	acceptHeaders := []string{"application/json"}

	opts1 := api.NewListOptions()
	opts1.Select.Add("*")
	u, e := s.client.ResolvePathWithDivision("{{.URL}}", 0)
	if e != nil {
		t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.List returned error: %v, with url {{.URL}}", e)
	}
	api.AddListOptionsToURL(u, opts1)

	opts2 := api.NewListOptions()
	opts2.Select.Add("*")
	opts2.SkipToken.Set(types.NewGUID())
	u2, e2 := s.client.ResolvePathWithDivision("{{.URL}}", 0)
	if e2 != nil {
		t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.List returned error: %v, with url {{.URL}}", e2)
	}
	api.AddListOptionsToURL(u2, opts2)

	g := {{.Name}}PrimaryPropertySample()
	gs := {{.Name}}StringJSONOfPrimaryProperty(g)
	mux.HandleFunc(u.Path, func(w http.ResponseWriter, r *http.Request) {
		testMethod(t, r, "GET")
		testHeader(t, r, "Accept", strings.Join(acceptHeaders, ", "))
		fmt.Fprint(w, `{ "d": { "__next": "` + u2.String() +  `", "results": [{ "{{.PrimaryProperty.Name}}": ` + gs +  `}]}}`)
	})

	entities, err := s.{{.Name}}.List(context.Background(),{{ if .NeedsDivision}} 0,{{end}} false, opts1)
	if err != nil {
		t.Errorf("{{.EndpointServiceName}}.List returned error: %v", err)
	}

	want := {{"[]"}}*{{.Name}}{{"{{"}}{{.PrimaryProperty.Name}}: g{{"}}"}}
	if !reflect.DeepEqual(entities, want) {
		t.Errorf("{{.EndpointServiceName}}.List returned %+v, want %+v", entities, want)
	}
}

func Test{{.EndpointServiceName}}_Get(t *testing.T) {
	acceptHeaders := []string{"application/json"}
	s1 := {{.Name}}PrimaryPropertySample()
	type args struct {
		ctx      context.Context
		division int
		id   *{{.PrimaryProperty.Type}}
	}
	tests := []struct {
		name    string
		args    args
		want   *{{.Name}}
		wantErr bool
	}{
		{
			"1",
			args{context.Background(), 0, s1},
			&{{.Name}}{{"{"}}{{.PrimaryProperty.Name}}: s1, MetaData: &api.MetaData{URI: &types.URL{URL: &url.URL{Scheme: "https", Host: "start.exactonline.nl"{{"}}}}"}},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s, mux, _, teardown := setup()
			defer teardown()

			b, e := s.client.ResolvePathWithDivision("{{.URL}}", 0)
			if e != nil {
				t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.Delete() returned error: %v, with url {{.URL}}", e)
			}

			u, e2 := api.AddOdataKeyToURL(b, tt.args.id)
			if e2 != nil {
				t.Errorf("api.AddOdataKeyToURL in {{.EndpointServiceName}}.Delete() returned error: %v", e2)
			}

			mux.HandleFunc(u.Path, func(w http.ResponseWriter, r *http.Request) {
				testMethod(t, r, "GET")
				testHeader(t, r, "Accept", strings.Join(acceptHeaders, ", "))
				b, _ := json.Marshal(tt.want)
				fmt.Fprint(w, `{"d":` + string(b) + `}`)
			})

			got, err := s.{{.Name}}.Get(tt.args.ctx, {{ if .NeedsDivision}}tt.args.division, {{end}}tt.args.id)
			if (err != nil) != tt.wantErr {
				t.Errorf("{{.EndpointServiceName}}.Get() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("{{.EndpointServiceName}}.Get() = %v, want %v", got, tt.want)
			}
		})
	}
}
{{end}}

{{ if (.HasMethod "POST")}}
func Test{{.EndpointServiceName}}_New(t *testing.T) {
	s, _, _, teardown := setup()
	defer teardown()
	got := s.{{.Name}}.New()
	want := &{{.Name}}{{"{}"}}
	if !reflect.DeepEqual(got, want) {
		t.Errorf("{{.EndpointServiceName}}.New() expected to return %v, got %v", want, got)
	}
}

func Test{{.EndpointServiceName}}_Create(t *testing.T) {
	acceptHeaders := []string{"application/json"}
	type args struct {
		ctx      context.Context
		division int
		entity   *{{.Name}}
	}
	tests := []struct {
		name    string
		args    args
		want    *{{.Name}}
		wantErr bool
	}{
		{
			"1",
			args{context.Background(), 0, &{{.Name}}{MetaData: &api.MetaData{URI: &types.URL{URL: &url.URL{Scheme: "https", Host: "start.exactonline.nl"{{"}}}}}"}},
			&{{.Name}}{MetaData: &api.MetaData{URI: &types.URL{URL: &url.URL{Scheme: "https", Host: "start.exactonline.nl"{{"}}}}"}},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s, mux, _, teardown := setup()
			defer teardown()

			u, e := s.client.ResolvePathWithDivision("{{.URL}}", 0)
			if e != nil {
				t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.Create returned error: %v, with url {{.URL}}", e)
			}

			mux.HandleFunc(u.Path, func(w http.ResponseWriter, r *http.Request) {
				testMethod(t, r, "POST")
				testHeader(t, r, "Accept", strings.Join(acceptHeaders, ", "))
				testHeader(t, r, "Content-Type", strings.Join(acceptHeaders, ", "))
				testBody(t, r, `{"__metadata":{"uri":"https://start.exactonline.nl"}}`+"\n")
				fmt.Fprint(w, `{ "d": { "__metadata": { "uri": "https://start.exactonline.nl"}}}`)
			})

			got, err := s.{{.Name}}.Create(tt.args.ctx, tt.args.division, tt.args.entity)
			if (err != nil) != tt.wantErr {
				t.Errorf("{{.EndpointServiceName}}.Create() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("{{.EndpointServiceName}}.Create() = %v, want %v", got, tt.want)
			}
		})
	}
}
{{end}}

{{ if (.HasMethod "PUT")}}
func Test{{.EndpointServiceName}}_Update(t *testing.T) {
	acceptHeaders := []string{"application/json"}
	type args struct {
		ctx      context.Context
		division int
		entity   *{{.Name}}
	}
	s1 := {{.Name}}PrimaryPropertySample()
	tests := []struct {
		name    string
		args    args
		want    *{{.Name}}
		wantErr bool
	}{
		{
			"1",
			args{context.Background(), 0, &{{.Name}}{{"{"}}{{.PrimaryProperty.Name}}: s1, MetaData: &api.MetaData{URI: &types.URL{URL: &url.URL{Scheme: "https", Host: "start.exactonline.nl"{{"}}}}}"}},
			&{{.Name}}{{"{"}}{{.PrimaryProperty.Name}}: s1, MetaData: &api.MetaData{URI: &types.URL{URL: &url.URL{Scheme: "https", Host: "start.exactonline.nl"{{"}}}}"}},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s, mux, _, teardown := setup()
			defer teardown()

			b, e := s.client.ResolvePathWithDivision("{{.URL}}", 0)
			if e != nil {
				t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.Update returned error: %v, with url {{.URL}}", e)
			}

			u, e2 := api.AddOdataKeyToURL(b, tt.args.entity.GetPrimary())
			if e2 != nil {
				t.Errorf("api.AddOdataKeyToURL in {{.EndpointServiceName}}.Update returned error: %v", e2)
			}

			mux.HandleFunc(u.Path, func(w http.ResponseWriter, r *http.Request) {
				testMethod(t, r, "PUT")
				testHeader(t, r, "Accept", strings.Join(acceptHeaders, ", "))
				testHeader(t, r, "Content-Type", strings.Join(acceptHeaders, ", "))
				b, _ := json.Marshal(tt.args.entity)
				testBody(t, r, string(b) + "\n")
				fmt.Fprint(w, `{"d":` + string(b) + `}`)
			})

			got, err := s.{{.Name}}.Update(tt.args.ctx, tt.args.division, tt.args.entity)
			if (err != nil) != tt.wantErr {
				t.Errorf("{{.EndpointServiceName}}.Update() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("{{.EndpointServiceName}}.Update() = %v, want %v", *got, *tt.want)
			}
		})
	}
}
{{end}}

{{ if (.HasMethod "DELETE")}}
func Test{{.EndpointServiceName}}_Delete(t *testing.T) {
	acceptHeaders := []string{"application/json"}
	type args struct {
		ctx      context.Context
		division int
		id   *{{.PrimaryProperty.Type}}
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		{
			"1",
			args{context.Background(), 0, {{.Name}}PrimaryPropertySample()},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s, mux, _, teardown := setup()
			defer teardown()

			b, e := s.client.ResolvePathWithDivision("{{.URL}}", 0)
			if e != nil {
				t.Errorf("s.client.ResolvePathWithDivision in {{.EndpointServiceName}}.Delete() returned error: %v, with url {{.URL}}", e)
			}

			u, e2 := api.AddOdataKeyToURL(b, tt.args.id)
			if e2 != nil {
				t.Errorf("api.AddOdataKeyToURL in {{.EndpointServiceName}}.Delete() returned error: %v", e2)
			}

			mux.HandleFunc(u.Path, func(w http.ResponseWriter, r *http.Request) {
				testMethod(t, r, "DELETE")
				testHeader(t, r, "Accept", strings.Join(acceptHeaders, ", "))
				testBody(t, r, "")
				w.WriteHeader(http.StatusNoContent)
			})

			err := s.{{.Name}}.Delete(tt.args.ctx, tt.args.division, tt.args.id)
			if (err != nil) != tt.wantErr {
				t.Errorf("{{.EndpointServiceName}}.Delete() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}
{{end}}
